# 2 Building Abstractions with Data

![](./img/ch2.png)

Programs are typically designed to model complex phenomena, and more often than not one（往往、常常） must construct computational objects that have several parts in order to model real-world phenomena that have several aspects. Thus, whereas our focus in chapter 1 was on building abstractions by combining procedures to form compound procedures, we turn in this chapter to another key aspect of any programming language: the means it provides for building abstractions by combining data objects to form compound data.

Why do we want compound data in a programming language? For the same reasons that we want compound procedures: **to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language. Just as the ability to define procedures enables us to deal with processes at a higher conceptual level than that of（高于） the primitive operations of the language, the ability to construct compound data objects enables us to deal with data at a higher conceptual level than that of the primitive data objects of the language.**

## 2.1 Introduction to Data Abstraction

**The basic idea of data abstraction is to structure the programs that are to use compound data objects so that they operate on “abstract data.” That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand.**

### 2.1.1 Example: Arithmetic Operations for Rational Numbers

```scheme
; 如果没有数据抽象：
(define (add-numerator n1 n2)
  (+ n1 n2))
(define (add-denominator d1 d2)
  (+ d1 d2))

(define (gcd a b)
  (if (= b 0) ; 当b或r为0时返回a。
      a
      (gcd b (remainder a b))))

; (define (make-rat n d) (cons n d))
(define (make-rat n d)
  (let ((g (abs (gcd n d))))
    (cons (/ n g) (/ d g)))) ; 也可以在selector中进行reduce。
(define (numer x) (car x))
(define (denom x) (cdr x))

; (define make-rat cons)
; (define numer car)
; (define denom cdr)

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(define one-third (make-rat 1 3))
(define one-half (make-rat 1 6))
(print-rat (add-rat one-third one-half)) ; 1/2
```

> Exercise 2.1: Define a better version of make-rat that handles both positive and negative arguments. make-rat should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.

```scheme
; (define (make-rat n d)
;   (let ((g (abs (gcd n d))))
;     (cond ((and (< n 0) (< d 0)) (cons (/ (- n) g) (/ (- d) g)))
;           ((and (> n 0) (< d 0)) (cons (/ (- n) g) (/ (- d) g)))
;           (else (cons (/ n g) (/ d g))))))
; 更简洁的实现，利用不论是题目中描述的哪种情况，共同点都是分母最终都为正，所以只要分母为负，就让分子分母同除一个负数，否则，同除一个正数。
(define (make-rat n d)
  (let ((g ((if (< d 0) - +) (abs (gcd n d)))))
    (cons (/ n g) (/ d g))))

(print-rat (make-rat 6 9)) ; 2/3 
(print-rat (make-rat -6 9)) ; -2/3 
(print-rat (make-rat 6 -9)) ; -2/3 
(print-rat (make-rat -6 -9)) ; 2/3
(print-rat (make-rat 1 -2)) ; -1/2
(print-rat (make-rat 6 -9)) ; -2/3
```

### 2.1.2 Abstraction Barriers

![](./img/Figure2.1.png)

**In effect, procedures at each level are the interfaces that define the abstraction barriers and connect the different levels.**

**At each level, the barrier separates the programs (above) that use the data abstraction from the programs (below) that implement the data abstraction.** 

**某一层使用与之相邻的下层提高的服务/接口来实现本层对上层提供的服务/接口。**。

> Exercise 2.2:

```scheme
;; ex 2.2.  Straightforward 
  
;; Point 
(define (make-point x y) (cons x y)) 
(define (x-point p) (car p)) 
(define (y-point p) (cdr p)) 
(define (print-point p) 
  (newline) 
  (display "(") 
  (display (x-point p)) 
  (display ",") 
  (display (y-point p)) 
  (display ")")) 
 
;; Segment 
(define (make-segment start-point end-point) 
  (cons start-point end-point)) 
(define (segment-start segment) (car segment)) 
(define (segment-end segment) (cdr segment)) 
 
(define (midpoint-segment segment) 
  (define (average a b) (/ (+ a b) 2.0)) 
  (let ((a (segment-start segment)) 
        (b (segment-end segment))) 
    (make-point (average (x-point a) 
                         (x-point b)) 
                (average (y-point a) 
                         (y-point b))))) 
 
;; Testing 
(define seg (make-segment (make-point 2 3) 
                          (make-point 10 15))) 
 
(print-point (midpoint-segment seg)) 
```

lackita: **I think the above solution misses part of the point about abstraction barriers; midpoint-segment reaches through both layers to achieve its goal.**

```scheme
(define (average-points a b) 
  (make-point (average (x-point a) (x-point b)) 
              (average (y-point a) (y-point b)))) 
 
(define (midpoint-segment seg) 
  (average-points (segment-start seg)
                  (segment-end seg)))
```

> Exercise 2.3: Implement a representation for rectangles in a plane. 

http://community.schemewiki.org/?sicp-ex-2.3

### 2.1.3 What Is Meant by Data?

In general, we can think of data as defined by some collection of selectors and constructors, together with specified conditions that these procedures must fulfill in order to be a valid representation.

对于上面实现的rational number，它的ctor和selector要满足的条件是：如果x是(make-rat n d)，那么(numer x)/(denom x) = n/d。

对于pair，它的ctor和selector要满足的条件是：for any objects x and y, if z is (cons x y) then (car z) is x and (cdr z) is y.

说到底，就是在数据类型的ctor和selector或其它相关的procedure构造的抽象屏障上，我们只需关心该数据类型的行为、功能是什么以及怎么使用。至于该数据类型是怎么实现的，客户并不需要关心。**客户只需要在这些抽象屏障上，在更高的概念层级上，在数据抽象和过程抽象赋予语言的更强的表达能力上，更好、更方便地构建程序即可**。

下面是pair的一个实现，那么它确实是这样实现的吗？不知道，也无所谓，只要它表现出来的行为满足上面的条件即可。

```scheme
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1: CONS" m))))
  dispatch)
(define (car z) (z 0))
(define (cdr z) (z 1))
```

> Exercise 2.4:

```scheme
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
; 在这种pair实现中，cdr的实现如下。
(define (cdr z)
  (z (lambda (p q) q)))
```

> Exercise 2.6: Church numerals.

http://community.schemewiki.org/?sicp-ex-2.6

http://markmiyashita.com/cs61a/higher_order_functions/church_numerals/

### 2.1.4 Extended Exercise: Interval Arithmetic

TODO

## 2.2 Hierarchical Data and the Closure Property!

下面这个图体现的就是pair这个数据结构。

![](./img/Figure2.2.png)

![](./img/Figure2.3.png)

### 2.2.1 Representing Sequences

下面这个图体现的就是**list，它是一个pair，cdr指向另一个list或指向nil(empty list)**。

![](./img/Figure2.4.png)

```scheme
(cons 2 (cons 3 4)) ; (2 3 . 4)
(cons 2 (cons 3 (cons 4 nil))) ; (2 3 4)
; (cadr ⟨arg⟩) = (car (cdr ⟨arg⟩))
```

对list的传统编程技术有：
1. “**cdring down**” the list.

   ```scheme
   (define (length items)
     (if (null? items)
         0
         (+ 1 (length (cdr items)))))
   (define (length-iter items)
     (define (iter items count)
       (if (null? items)
           count
           (iter (cdr items) (+ count 1))))
     (iter items 0))
   ```

2. “**cons up**” an answer list while cdring down a list.

   ```scheme
   (define (append list1 list2)
     (if (null? list1)
         list2
         (cons (car list1) (append (cdr list1) list2))))
   (append '(1 2 3) '(4 5 6))
   ```

> Exercise 2.17:

```scheme
; returns the list that contains only the last element of a given (nonempty) list
(define (last-pair lst)
  (if (null? (cdr lst))
      lst
      (last-pair (cdr lst))))

(last-pair (list 23 72 149 34)) ; (34)
```



> Exercise 2.19:

```scheme
; For the last part of the exercise. The order of the coins does not affect the result. **Becuase the procedure computes all possible combinations.** But it does affect the speed of the computation. If you start with the lower valued coins, it'll take much longer.
(define (no-more? lst) (null? lst))
(define (except-first-denomination lst) (cdr lst))
(define (first-denomination lst) (car lst))

(define (cc amount coin-values)
  (cond ((= amount 0) 1) ; 恰好零钱换到0，即这是一条有效的路径，即这是一种有效的兑换零钱的方式，故返回1。
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination
                 coin-values))
            (cc (- amount
                   (first-denomination
                    coin-values))
                coin-values)))))

(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(cc 100 us-coins)

(define (timed-cc amount coin-values start-time) 
  (cc amount coin-values) 
  (- (runtime) start-time))
(timed-cc 200 us-coins (runtime))       ;19518
(timed-cc 200 (reverse2 us-coins) (runtime)) ;39055
```

> Exercise 2.20:

```scheme
; (define (f x y . z) ⟨body⟩)
; (f 1 2 3 4 5 6)
; then in the body of f, x will be 1, y will be 2, and z will be the list (3 4 5 6).

(define (even? x) (= (remainder x 2) 0))

(define (same-parity . lst)
  (define (filter x)
    (if (even? (car lst))
        (even? x)
        (not (even? x))))
  (define (iter lst)
    (cond ((null? lst) nil)
          ((filter (car lst)) (cons (car lst) (iter (cdr lst))))
          (else (iter (cdr lst)))))
  (iter lst))

; 更好的函数签名是：
; (define (same-parity first . rest)

(same-parity 1 2 3 4 5 6 7) ; (1 3 5 7)
(same-parity 2 3 4 5 6 7) ; (2 4 6)
```

#### Mapping over lists

```scheme
(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items)
                        factor))))
(scale-list (list 1 2 3 4 5) 10)
```

提取出一个通用模式map：

```scheme
; 对输入list的每个元素应用proc，返回新的list。
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
(map (lambda (x) (* x x)) (list 1 2 3 4))
(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
```

**map is an important construct, not only because it captures a common pattern, but because it establishes a higher level of abstraction in dealing with lists**. In the original definition of scale-list, the recursive structure of the program draws attention to the element-by-element processing of the list. Defining scale-list in terms of map suppresses that level of detail and emphasizes that scaling transforms a list of elements to a list of results. **The difference between the two definitions is not that the computer is performing a different process (it isn’t) but that we think about the process differently. In effect, map helps establish an abstraction barrier that isolates the implementation of procedures that transform lists from the details of how the elements of the list are extracted and combined.** Like the barriers shown in Figure 2.1, this abstraction gives us the flexibility to change the low-level details of how sequences are implemented, while preserving the conceptual framework of operations that transform sequences to sequences. Section 2.2.3 expands on this use of sequences as a framework for organizing programs.

> Exercise 2.23:

```scheme
(define (for-each proc lst)
  (cond ((null? lst) #t)
        (else (proc (car lst)) (for-each proc (cdr lst)))))

; 返回#t，不关心返回值，返回什么都行。
(for-each (lambda (x)
            (newline)
            (display x))
          (list 57 321 88))
```

### 2.2.2 Hierarchical Structures

![](./img/Figure2.5.png)

![](./img/Figure2.6.png)

Another way **to think of sequences whose elements are sequences is as trees. The elements of the sequence are the branches of the tree, and elements that are themselves sequences are subtrees.** Figure 2.6 shows the structure in Figure 2.5 viewed as a tree.（也就是**树的孩子-兄弟表示法**）

```scheme
(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x)) ; 第一棵子树的孩子子树。
                 (count-leaves (cdr x)))))) ; 同一层上的其它兄弟子树。
```

> Exercise 2.24: Suppose we evaluate the expression (list 1 (list 2 (list 3 4))). Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in Figure 2.6).

> Exercise 2.25: Give combinations of cars and cdrs that will pick 7 from each of the following lists:
>
> ```scheme
> (1 3 (5 7) 9)
> ((7))
> (1 (2 (3 (4 (5 (6 7))))))
> ```

> Exercise 2.26: Suppose we define x and y to be two lists:
>
> ```scheme
> (define x (list 1 2 3))
> (define y (list 4 5 6))
> ```
>
> What result is printed by the interpreter in response to evaluating each of the following expressions:
>
> ```scheme
> (append x y)
> (cons x y)
> (list x y)
> ```

对于以上三题，要回顾上面的图，这里有一个[可视化工具](https://code.cs61a.org/)。

> Exercise 2.27: Modify your reverse procedure of Exercise 2.18 to produce a deep-reverse procedure that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well.

```scheme
(define (reverse lst)
  (define (iter lst result)
    (if (null? lst)
        result
        (iter (cdr lst) (cons (car lst) result))))
  (iter lst nil))
; 对比上面，只需修改一处。
(define (deep-reverse tree)
  (define (iter tree result)
    (if (null? tree)
        result
        (iter (cdr tree) (cons (if (list? (car tree))
                                   (iter (car tree) nil)
                                   (car tree))
                               result)))) ; 头插法。
  (iter tree nil))

(define x (list (list 1 2) (list 3 4)))
(deep-reverse x) ; ((4 3) (2 1))
```

> Exercise 2.28:

```scheme
; 迭代递归过程，关键在于递归先求值/展开，所以这里我们从最右边、最底下的子树/边缘/叶子开始，采用头插法来构造result。
(define (fringe tree)
  (define (iter tree result)
    (cond ((null? tree) result)
          ((not (pair? tree)) (cons tree result)) ; 如果tree不是pair，而是primitive expression，即叶子。
          (else (iter (car tree) (iter (cdr tree) result)))))
  (iter tree nil))

(define x (list (list 1 2) (list 3 4)))
(fringe x) ; (1 2 3 4)
(fringe (list x x)) ; (1 2 3 4 1 2 3 4)
```

> Exercise 2.29:

```scheme
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile))) ; 注意如果mobile是一个pair而不是list的话，那么这里就可以直接用(cdr mobile)。
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

(define (total-weight mobile)
  ; 由于mobile的定义就是必然有两个分支，所以这里就判断mobile为null?，仅仅只是caller调用时第一次检查而已，而不是为了在递归调用中检查。
  (cond ((null? mobile) 0)
        ((not (pair? mobile)) mobile) ; 返回叶子上的权值。
        (else (+
               (total-weight (branch-structure (left-branch mobile)))
               (total-weight (branch-structure (right-branch mobile)))))))

(define a (make-mobile (make-branch 2 3) (make-branch 2 3))) 
(total-weight a) ;; 6

(define (torque branch)
  (* (branch-length branch) (total-weight (branch-structure branch))))

; 在命令式编程中，如果可以用全局变量的话，这个procedure可以做得更高效一点，设置一个全局的bool变量，procedure接受两个branch，从最底层开始，返回两个branch的torque，然后比较是否相等，设置bool变量，返回**两个torque的和**（这也就是往上收缩的过程）供上一层递归调用比较。
(define (balanced? mobile)
  (cond ((null? mobile) #t) ; 这个检查的目的同上。
        ((not (pair? mobile)) #t) ; 返回叶子上的权值。
        (else (and (= (torque (left-branch mobile)) (torque (right-branch mobile)))
                   (balanced? (branch-structure (left-branch mobile)))
                   (balanced? (branch-structure (right-branch mobile)))))))

(define d (make-mobile (make-branch 10 a) (make-branch 12 5))) 
;; Looks like: ((10 ((2 3) (2 3))) (12 5)) 
 
(balanced? d) ;; #t
```

#### Mapping over trees

```scheme
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor)) ; 当前子树是叶子，直接处理返回。
        (else (cons (scale-tree (car tree) factor) ; 当前子树的孩子也是一棵树，递归处理。
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10) ; (10 (20 (30 40) 50) (60 70))

; 使用map，map会对输入的list的每一个pair的car应用给定的操作。
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
       (if (pair? sub-tree) ; 当前子树是叶子，直接处理返回。
           (scale-tree sub-tree factor) ; 当前子树的孩子也是一棵树，递归处理。
           (* sub-tree factor)))
       tree))
```

> Exercise 2.31:

```scheme
(define (tree-map proc tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (proc tree))
        (else (cons (tree-map proc (car tree))
                    (tree-map proc (cdr tree))))))
(define (square-tree tree) (tree-map square tree))
(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
```

> Exercise 2.32: We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is (1 2 3), then the set of all subsets is (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).

```scheme
(define (subsets s)
  (if (null? s)
      (list nil) ;; initially had nil, always got () back! 
      (let ((rest (subsets (cdr s))) ; XXX 递归先展开。
            (first (car s)))
        (append rest (map (lambda (x) (cons first x)) rest)))))
(subsets (list 1 2 3))
```

### 2.2.3 Sequences as Conventional Interfaces

